<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Digital Ideas Metaverse – VRM Idle/Walk</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#101015; color:#eaeaf0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    #myCanvas { display:block; width:100vw; height:100vh; }
    .ui {
      position: fixed; inset: 12px 12px auto auto; display:flex; gap:8px; z-index: 10;
      background: rgba(12,12,16,.6); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
      border:1px solid rgba(255,255,255,.08); padding:8px 10px; border-radius:10px;
    }
    .ui input[type="file"] { display:none; }
    .ui label, .ui button {
      cursor:pointer; border:none; border-radius:8px; padding:8px 10px; color:#eaeaf0; background:#2b2f3a; transition:.15s; font-size:14px;
    }
    .ui label:hover, .ui button:hover { background:#3b4252; }
    .help {
      position: fixed; left: 12px; bottom: 12px; z-index: 10; opacity: .9; font-size: 12px; line-height:1.5;
      background: rgba(12,12,16,.55); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:8px 10px;
    }
    .label {
      color:#fff; padding:.25rem .5rem; background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.15); border-radius:8px;
      font-size:12px; white-space:nowrap;
    }
  </style>

  <!-- CDN Import Map（Three.js / Examples / three-vrm） -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.3.6/lib/three-vrm.module.min.js"
    }
  }
  </script>
</head>
<body>
  <div class="ui">
    <input id="vrmFile" type="file" accept=".vrm" />
    <label for="vrmFile">VRMを読み込む</label>
    <button onclick="location.reload()">リセット</button>
  </div>
  <div class="help">
    <b>移動</b>：W/A/S/D　<b>走る</b>：Shift　<b>視点</b>：ドラッグ（マウス）<br/>
    停止＝<code>idle.fbx</code>、歩行/走行＝<code>walk.fbx</code> を再生（存在する場合）。<br/>
    置いてあれば <code>asset/vrm/test.vrm</code> を自動ロード。
  </div>
  <canvas id="myCanvas"></canvas>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
    import * as SkeletonUtils from "three/addons/utils/SkeletonUtils.js";
    import { CSS2DRenderer, CSS2DObject } from "three/addons/renderers/CSS2DRenderer.js";
    import { VRMLoaderPlugin } from "pixiv/three-vrm";

    // ===== 基本セットアップ =====
    const canvas = document.getElementById("myCanvas");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0c0c12);

    const camera = new THREE.PerspectiveCamera(48, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.1, 6);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0,1.4,0);
    controls.enableDamping = true;
    controls.enablePan = false;

    scene.add(new THREE.AmbientLight(0xffffff, .7));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(5, 10, 3);
    scene.add(dir);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(80,80),
      new THREE.MeshStandardMaterial({ color:0x1a1a22, roughness:.95 })
    );
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    const grid = new THREE.GridHelper(80, 80, 0x333846, 0x202530);
    grid.material.opacity = .6; grid.material.transparent = true;
    scene.add(grid);

    // 2Dラベル（展示キャプション）
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(innerWidth, innerHeight);
    labelRenderer.domElement.style.position = "fixed";
    labelRenderer.domElement.style.inset = "0";
    labelRenderer.domElement.style.pointerEvents = "none";
    document.body.appendChild(labelRenderer.domElement);

    // ===== 展示ブース（例） =====
    const BOOTHS = [
      { pos:[ -8, 1.1, -8], title:"AIプロダクト：要件定義支援", color:0x3a73ff },
      { pos:[  0, 1.1, -8], title:"可視化：工場DXダッシュボード", color:0xff6f3a },
      { pos:[  8, 1.1, -8], title:"自動化：帳票RPA + GPT", color:0x22cc88 },
      { pos:[ -8, 1.1,  0], title:"UI/UX：セルフ改善アプリ", color:0xb353ff },
      { pos:[  0, 1.1,  0], title:"3D/Metaverse：展示空間", color:0xf0bf2a },
      { pos:[  8, 1.1,  0], title:"教育：生成AIトレーニング", color:0x39c0f0 },
      { pos:[ -8, 1.1,  8], title:"製造：現場AIアシスタント", color:0xf06292 },
      { pos:[  0, 1.1,  8], title:"検索：社内ナレッジRAG", color:0x7bd88f },
      { pos:[  8, 1.1,  8], title:"PowerApps：業務アプリ群", color:0xffc66d },
    ];
    const boothBoxes = [];
    for (const b of BOOTHS) {
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(3.2, 2.2, 1.2),
        new THREE.MeshStandardMaterial({ color: b.color, metalness:.2, roughness:.6 })
      );
      box.position.set(...b.pos);
      scene.add(box);
      boothBoxes.push(box);

      const labelEl = document.createElement("div");
      labelEl.className = "label";
      labelEl.textContent = b.title;
      const label = new CSS2DObject(labelEl);
      label.position.set(0, 1.5, 0);
      box.add(label);
    }
    const BOUNDS = 39; // 移動境界

    // ===== VRM / FBX 読み込み =====
    const gltfLoader = new GLTFLoader();
    gltfLoader.register(p => new VRMLoaderPlugin(p));
    const fbxLoader = new FBXLoader();

    function loadVRM(url){
      return new Promise((resolve)=>{
        gltfLoader.load(url, g => resolve(g.userData.vrm),
          undefined, err => { console.warn("VRM load failed:", err); resolve(null); });
      });
    }

    // Mixamo FBX → VRM AnimationClip にリターゲット
    function loadMixamoClip(url, vrm){
      return new Promise((resolve)=>{
        fbxLoader.load(url, fbx=>{
          const srcClip = fbx.animations?.[0];
          if(!srcClip){ console.warn("No animations in", url); resolve(null); return; }
          try { vrm?.humanoid?.resetNormalizedPose?.(); } catch {}
          let clip = null;
          try {
            clip = SkeletonUtils.retargetClip(vrm.scene, fbx, srcClip, {
              useTargetMatrix: true, preserveIK: false
            });
          } catch(e){ console.error("retargetClip failed:", e); resolve(null); return; }
          clip.name = srcClip.name || "mixamo";
          clip.tracks = clip.tracks.filter(t => t?.times?.length);
          resolve(clip);
        }, undefined, err => { console.error("FBX load failed:", url, err); resolve(null); });
      });
    }

    let vrm = null, mixer = null;
    let idleAction = null, walkAction = null, currentAction = null;

    function crossFade(to, dur=0.2){
      if(!to || currentAction===to) return;
      if(currentAction) currentAction.fadeOut(dur);
      to.reset().fadeIn(dur).play();
      currentAction = to;
    }

    async function setupVRM(v){
      if(vrm) scene.remove(vrm.scene);
      vrm = v;
      vrm.scene.traverse(o=>o.frustumCulled=false);
      vrm.scene.position.set(0,0,0);
      scene.add(vrm.scene);

      mixer = new THREE.AnimationMixer(vrm.scene);
      idleAction = walkAction = currentAction = null;

      // あるものだけ読み込む（失敗したら null）
      const [idleClip, walkClip] = await Promise.all([
        loadMixamoClip("./asset/animation/idle.fbx", vrm),
        loadMixamoClip("./asset/animation/walk.fbx", vrm)
      ]);
      if(idleClip){ idleAction = mixer.clipAction(idleClip); idleAction.setLoop(THREE.LoopRepeat, Infinity); idleAction.weight=0; }
      if(walkClip){ walkAction = mixer.clipAction(walkClip); walkAction.setLoop(THREE.LoopRepeat, Infinity); walkAction.weight=0; }

      // 初期は idle（無ければ walk）
      if(idleAction) crossFade(idleAction,.2);
      else if(walkAction) crossFade(walkAction,.2);
    }

    // デフォルトVRM（任意）
    (async ()=>{
      const v = await loadVRM("./asset/vrm/test.vrm");
      if(v) await setupVRM(v);
      else console.log("default VRM not found. Use the upload button.");
    })();

    // ファイルアップロード：VRM
    document.getElementById("vrmFile").addEventListener("change", async (e)=>{
      const f = e.target.files?.[0]; if(!f) return;
      const url = URL.createObjectURL(f);
      const v = await loadVRM(url);
      if(v) await setupVRM(v);
    });

    // ===== 入力と移動（第三者視点・カメラ追従） =====
    const keys = { w:false,a:false,s:false,d:false, shift:false, arrowup:false, arrowleft:false, arrowdown:false, arrowright:false };
    addEventListener("keydown", e=>{ const k=e.key.toLowerCase(); if(k in keys) keys[k]=true; });
    addEventListener("keyup",   e=>{ const k=e.key.toLowerCase(); if(k in keys) keys[k]=false; });

    const player = { yaw:0, speedWalk:1.8, speedRun:3.2 };
    function isMoving(){ return keys.w||keys.a||keys.s||keys.d||keys.arrowup||keys.arrowleft||keys.arrowdown||keys.arrowright; }

    function updatePlayer(dt){
      if(!vrm) return;
      const obj = vrm.scene;
      const speed = keys.shift ? player.speedRun : player.speedWalk;
      const dir = new THREE.Vector3((keys.d?1:0)-(keys.a?1:0), 0, (keys.s?1:0)-(keys.w?1:0));

      if(dir.lengthSq()>0){
        dir.normalize();
        // カメラ基準 → ワールド方向
        const camYaw = Math.atan2(camera.position.x - obj.position.x, camera.position.z - obj.position.z);
        const worldDir = new THREE.Vector3(
          Math.sin(camYaw) * -dir.z + Math.cos(camYaw) * dir.x, 0,
          Math.cos(camYaw) * -dir.z - Math.sin(camYaw) * dir.x
        ).normalize();

        obj.position.addScaledVector(worldDir, speed*dt);
        const targetYaw = Math.atan2(worldDir.x, worldDir.z);
        const deltaYaw = ((targetYaw - player.yaw + Math.PI*3) % (Math.PI*2)) - Math.PI;
        player.yaw += deltaYaw * Math.min(1, dt*10);
        obj.rotation.y = player.yaw;

        // アニメ：移動→walk（Shiftで速度UP）
        if(walkAction){
          walkAction.timeScale = keys.shift ? 1.3 : 1.0;
          crossFade(walkAction, 0.15);
        }
      }else{
        // アニメ：停止→idle
        if(idleAction) crossFade(idleAction, 0.2);
      }

      // 簡易衝突（ブースにめり込まない）
      for (const box of boothBoxes){
        const p = obj.position, bp = box.position, sx = 1.6, sz = 0.9; // 半サイズ
        const dx = Math.max(Math.abs(p.x - bp.x) - (sx + 0.4), 0);
        const dz = Math.max(Math.abs(p.z - bp.z) - (sz + 0.4), 0);
        if (dx === 0 && dz === 0){
          if (Math.abs(p.x - bp.x) - sx > Math.abs(p.z - bp.z) - sz) {
            p.x = bp.x + Math.sign(p.x - bp.x) * (sx + 0.41);
          } else {
            p.z = bp.z + Math.sign(p.z - bp.z) * (sz + 0.41);
          }
        }
      }
      // 境界
      obj.position.x = THREE.MathUtils.clamp(obj.position.x, -BOUNDS, BOUNDS);
      obj.position.z = THREE.MathUtils.clamp(obj.position.z, -BOUNDS, BOUNDS);
    }

    // カメラ追従（肩越し）
    const camOffset = new THREE.Vector3(0, 1.5, 3.5);
    function updateCamera(dt){
      if(!vrm){ controls.update(); return; }
      const rot = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), player.yaw);
      const desired = vrm.scene.position.clone().add(camOffset.clone().applyQuaternion(rot));
      camera.position.lerp(desired, 1 - Math.pow(0.001, dt));
      controls.target.lerp(vrm.scene.position.clone().add(new THREE.Vector3(0,1.2,0)), 1 - Math.pow(0.001, dt));
      controls.update();
    }

    // ループ
    const clock = new THREE.Clock();
    function tick(){
      const dt = clock.getDelta();
      if(vrm) vrm.update(dt);
      if(mixer) mixer.update(dt);
      updatePlayer(dt);
      updateCamera(dt);
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();

    // リサイズ
    addEventListener("resize", ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      labelRenderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
